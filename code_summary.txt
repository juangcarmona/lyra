==== src/Lyra/Startup.cs ====
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Lyra.Services;
using Lyra.Logging;
using Microsoft.Extensions.Logging.Console;

namespace Lyra
{
    public static class Startup
    {
        public static ServiceProvider ConfigureServices()
        {
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
                .Build();

            return new ServiceCollection()
                .AddLogging(loggingBuilder =>
                {
                    loggingBuilder.ClearProviders(); // Remove default providers
                    loggingBuilder.AddConsoleFormatter<SimpleConsoleFormatter, ConsoleFormatterOptions>();
                    loggingBuilder.AddConsole(options =>
                    {
                        options.FormatterName = "simple"; // Use custom formatter
                    });
                    loggingBuilder.SetMinimumLevel(LogLevel.Debug);
                })
                .AddSingleton<DownloaderService>()
                .AddSingleton<ConversionService>()
                .BuildServiceProvider();
        }
    }
}



==== src/Lyra/Logging/SimpleConsoleFormatter.cs ====
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Logging.Console;

namespace Lyra.Logging
{
    public class SimpleConsoleFormatter : ConsoleFormatter
    {
        public SimpleConsoleFormatter() : base("simple") { }

        public override void Write<TState>(
            in LogEntry<TState> logEntry,
            IExternalScopeProvider? scopeProvider,
            TextWriter textWriter)
        {
            if (logEntry.Formatter == null)
                return;

            string message = logEntry.Formatter(logEntry.State, logEntry.Exception);

            if (string.IsNullOrEmpty(message))
                return;

            // Set console color based on log level
            ConsoleColor originalColor = Console.ForegroundColor;
            Console.ForegroundColor = logEntry.LogLevel switch
            {
                LogLevel.Information => ConsoleColor.Green,
                LogLevel.Warning => ConsoleColor.Yellow,
                LogLevel.Error => ConsoleColor.Red,
                LogLevel.Critical => ConsoleColor.DarkRed,
                _ => ConsoleColor.Gray
            };

            textWriter.WriteLine(message);
            Console.ForegroundColor = originalColor;
        }
    }
}



==== src/Lyra/Program.cs ====
Ôªøusing Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Lyra.Services;

namespace Lyra
{
    class Program
    {
        static async Task Main(string[] args)
        {
            var serviceProvider = Startup.ConfigureServices();
            var logger = serviceProvider.GetRequiredService<ILogger<Program>>();

            PrintBanner(logger);

            var downloader = serviceProvider.GetRequiredService<DownloaderService>();

            if (args.Length == 0)
            {
                PrintUsage(logger);
                return;
            }

            if (args[0] == "--video" && args.Length > 1)
            {
                string videoUrl = args[1];
                await downloader.DownloadVideo(videoUrl);
            }
            else if (args[0] == "--playlist" && args.Length > 1)
            {
                string playlistUrl = args[1];
                await downloader.DownloadPlaylist(playlistUrl);
            }
            else
            {
                logger.LogError("‚ùå Invalid command.");
                PrintUsage(logger);
            }
        }

        static void PrintBanner(ILogger logger)
        {
            logger.LogInformation("===============================================");
            logger.LogInformation("     üéµ LYRA - Lightweight Youtube Ripping Assistant üé∂");
            logger.LogInformation("===============================================");
        }

        static void PrintUsage(ILogger logger)
        {
            logger.LogWarning("Usage:");
            logger.LogWarning("  lyra --video <YouTube URL>      # Download a single video");
            logger.LogWarning("  lyra --playlist <Playlist URL>  # Download all audios from a playlist\n");
        }
    }
}



==== src/Lyra/Services/ConversionService.cs ====
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Xabe.FFmpeg;
using Xabe.FFmpeg.Downloader;

namespace Lyra.Services
{
    public class ConversionService
    {
        private readonly ILogger<ConversionService> _logger;
        private static readonly string _executionPath = AppContext.BaseDirectory;
        private static readonly string _ffmpegPath = Path.Combine(_executionPath, "ffmpeg");
        private static readonly string _ffprobePath = Path.Combine(_executionPath, "ffprobe");

        public ConversionService(ILogger<ConversionService> logger)
        {
            _logger = logger;
            EnsureFFmpegIsAvailable().Wait();
        }

        /// <summary>
        /// Ensures FFmpeg is downloaded and available in the execution directory.
        /// </summary>
        private async Task EnsureFFmpegIsAvailable()
        {
            try
            {
                FFmpeg.SetExecutablesPath(_executionPath);

                if (!File.Exists(_ffmpegPath) || !File.Exists(_ffprobePath))
                {
                    _logger.LogWarning("üì• FFmpeg not found in execution directory, downloading latest version...");
                    await FFmpegDownloader.GetLatestVersion(FFmpegVersion.Official, _executionPath);
                    _logger.LogInformation("‚úÖ FFmpeg is ready at execution directory!");
                }
                else
                {
                    _logger.LogInformation($"‚úÖ FFmpeg found in execution directory: {_executionPath}");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"‚ùå Failed to set up FFmpeg: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Converts a video file to MP3 format.
        /// </summary>
        /// <param name="videoPath">Path to the video file.</param>
        /// <returns>Path to the converted MP3 file.</returns>
        public async Task<string> ConvertToMp3(string videoPath)
        {
            string sanitizedVideoPath = SanitizeFileName(videoPath);
            string mp3Path = Path.Combine(
                Path.GetDirectoryName(sanitizedVideoPath),
                Path.GetFileNameWithoutExtension(sanitizedVideoPath) + ".mp3"
            );

            try
            {
                _logger.LogInformation($"üéµ Starting MP3 conversion for: {sanitizedVideoPath}");

                // Validate video file existence
                if (!File.Exists(sanitizedVideoPath))
                {
                    _logger.LogError($"‚ùå Video file not found: {sanitizedVideoPath}");
                    throw new FileNotFoundException("Video file not found", sanitizedVideoPath);
                }

                // Validate FFmpeg existence
                if (!File.Exists(_ffmpegPath) || !File.Exists(_ffprobePath))
                {
                    _logger.LogError("‚ùå FFmpeg executables are missing after supposed download!");
                    throw new FileNotFoundException("FFmpeg or FFprobe not found in execution directory.");
                }

                FFmpeg.SetExecutablesPath(_executionPath);

                _logger.LogInformation($"üîÑ Extracting audio using FFmpeg...");
                var conversion = await FFmpeg.Conversions.FromSnippet.ExtractAudio(sanitizedVideoPath, mp3Path);

                if (conversion == null)
                {
                    _logger.LogError("‚ùå FFmpeg.ExtractAudio returned null. Aborting conversion.");
                    throw new NullReferenceException("FFmpeg.ExtractAudio returned null.");
                }

                conversion.OnProgress += (sender, args) =>
                {
                    _logger.LogInformation($"üîπ Conversion Progress: {args.Percent}%");
                };

                await conversion.Start();
                _logger.LogInformation($"‚úÖ MP3 saved: {mp3Path}");

                return mp3Path;
            }
            catch (Exception ex)
            {
                _logger.LogError($"‚ùå Error during conversion: {ex.Message}");

                if (File.Exists(mp3Path))
                {
                    File.Delete(mp3Path);
                    _logger.LogWarning($"üóëÔ∏è MP3 deleted due to error: {mp3Path}");
                }

                throw;
            }
        }

        /// <summary>
        /// Sanitizes file names to prevent issues with special characters.
        /// </summary>
        /// <param name="filePath">Original file path.</param>
        /// <returns>Sanitized file path.</returns>
        private string SanitizeFileName(string filePath)
        {
            string directory = Path.GetDirectoryName(filePath) ?? _executionPath;
            string filename = Path.GetFileNameWithoutExtension(filePath);
            string extension = Path.GetExtension(filePath);

            // Convert filename to snake_case and remove unsafe characters
            filename = Regex.Replace(filename, @"\s+", "_"); // Replace spaces with underscores
            filename = Regex.Replace(filename, @"[^a-zA-Z0-9_-]", ""); // Remove unsafe characters

            string sanitizedPath = Path.Combine(directory, filename + extension);
            _logger.LogDebug($"üîç Sanitized file path: {sanitizedPath}");
            return sanitizedPath;
        }
    }
}



==== src/Lyra/Services/DownloaderService.cs ====
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using VideoLibrary;

namespace Lyra.Services
{
    public class DownloaderService
    {
        private readonly ILogger<DownloaderService> _logger;
        private readonly ConversionService _conversionService;
        private static readonly HttpClient _httpClient = new HttpClient();
        private readonly string _downloadPath = Path.Combine(Environment.CurrentDirectory, "downloads");

        public DownloaderService(ILogger<DownloaderService> logger, ConversionService conversionService)
        {
            _logger = logger;
            _conversionService = conversionService;
            Directory.CreateDirectory(_downloadPath);
        }

        public async Task DownloadVideo(string url)
        {
            _logger.LogInformation($"üé¨ Downloading video: {url}");

            try
            {
                var youtube = YouTube.Default;
                var video = await youtube.GetVideoAsync(url);

                // Sanitize file name
                string sanitizedFileName = SanitizeFileName(video.FullName);
                string videoPath = Path.Combine(_downloadPath, sanitizedFileName);

                await File.WriteAllBytesAsync(videoPath, await video.GetBytesAsync());

                _logger.LogInformation($"‚úÖ Download complete: {videoPath}");

                // Convert to MP3
                await _conversionService.ConvertToMp3(videoPath);

                // Optional: Delete the original video file after conversion
                File.Delete(videoPath);
                _logger.LogInformation($"üóëÔ∏è Deleted original video file: {videoPath}");
            }
            catch (Exception ex)
            {
                _logger.LogError($"‚ùå Error downloading video: {ex.Message}");
            }
        }
        public async Task DownloadPlaylist(string playlistUrl)
        {
            _logger.LogInformation($"üìú Fetching playlist: {playlistUrl}");

            try
            {
                // Fetch the playlist webpage
                string htmlContent = await _httpClient.GetStringAsync(playlistUrl);

                // Extract video URLs using regex (matches video IDs from playlist page)
                var matches = Regex.Matches(htmlContent, @"watch\?v=(.{11})");
                var videoUrls = new HashSet<string>(); // Use HashSet to avoid duplicates

                foreach (Match match in matches)
                {
                    string videoId = match.Groups[1].Value;
                    string videoUrl = $"https://www.youtube.com/watch?v={videoId}";

                    if (videoUrls.Add(videoUrl)) // Adds only if it's unique
                    {
                        _logger.LogDebug($"üîó Found video: {videoUrl}");
                    }
                }

                if (videoUrls.Count == 0)
                {
                    _logger.LogWarning("‚ùå No videos found in playlist.");
                    return;
                }

                _logger.LogInformation($"üîπ Found {videoUrls.Count} videos in playlist.");

                // Download each video
                foreach (var url in videoUrls)
                {
                    await DownloadVideo(url);
                }

                _logger.LogInformation($"‚úÖ Playlist downloaded successfully.");
            }
            catch (Exception ex)
            {
                _logger.LogError($"‚ö†Ô∏è Error fetching playlist: {ex.Message}");
            }
        }

        private string SanitizeFileName(string fileName)
        {
            string sanitized = Regex.Replace(fileName, @"[^\w\d\-_]", "_"); // Keep alphanumeric, dash, and underscore
            sanitized = Regex.Replace(sanitized, @"_+", "_"); // Replace multiple underscores with a single one
            sanitized = sanitized.Trim('_').ToLower(); // Trim leading/trailing underscores, enforce lowercase
            return sanitized;
        }
    }
}



==== src/Lyra/Services/FFmpegChecker.cs ====
using System;
using System.IO;
using System.Runtime.InteropServices;
using Microsoft.Extensions.Logging;
using Xabe.FFmpeg;

namespace Lyra.Utils
{
    public static class FFmpegChecker
    {
        public static void EnsureFFmpegIsAvailable(ILogger logger)
        {
            try
            {
                // Check if FFmpeg path is set
                string ffmpegPath = FFmpeg.ExecutablesPath;

                if (string.IsNullOrEmpty(ffmpegPath) || !File.Exists(Path.Combine(ffmpegPath, GetFFmpegExecutable())))
                {
                    throw new Exception("FFmpeg not found");
                }

                logger.LogInformation("‚úÖ FFmpeg is available at: " + ffmpegPath);
            }
            catch (Exception)
            {
                logger.LogError("‚ùå FFmpeg is not installed or not found in the system PATH.");
                ProvideInstallationInstructions(logger);
                throw;
            }
        }

        private static void ProvideInstallationInstructions(ILogger logger)
        {
            logger.LogWarning("\nüîπ Installation Instructions:");

            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                logger.LogWarning("  üìå Windows: Download FFmpeg from https://ffmpeg.org/download.html");
                logger.LogWarning("  üìå Add the 'bin' folder to your system PATH.");
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                logger.LogWarning("  üçè macOS: Install FFmpeg using Homebrew:");
                logger.LogWarning("    brew install ffmpeg");
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                logger.LogWarning("  üêß Linux: Install FFmpeg using your package manager:");
                logger.LogWarning("    sudo apt install ffmpeg  (Debian/Ubuntu)");
                logger.LogWarning("    sudo dnf install ffmpeg  (Fedora)");
                logger.LogWarning("    sudo pacman -S ffmpeg  (Arch)");
            }
            else
            {
                logger.LogWarning("  ‚ö†Ô∏è Unknown OS detected. Please install FFmpeg manually from https://ffmpeg.org/download.html");
            }
        }

        private static string GetFFmpegExecutable()
        {
            return RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "ffmpeg.exe" : "ffmpeg";
        }
    }
}



==== src/Lyra/Services/PlaylistExtractor.cs ====
// using System;
// using System.Collections.Generic;
// using System.Linq;
// using System.Threading.Tasks;
// using YoutubeExplode;
// using YoutubeExplode.Common;
// using YoutubeExplode.Playlists;
// using VideoLibrary;

// namespace Lyra.Services
// {
//     public class PlaylistExtractor
//     {
//         private readonly YoutubeClient _youtubeClient = new YoutubeClient();

//         public async Task<List<YouTubeVideo>> GetVideosFromPlaylist(string playlistUrl)
//         {
//             var videos = new List<YouTubeVideo>();

//             try
//             {
//                 var playlist = await _youtubeClient.Playlists.GetAsync(playlistUrl);
//                 var videoUrls = playlist.Videos.Where(v => v.Status == VideoStatus.Ok).Select(v => v.Url).ToList();

//                 foreach (var url in videoUrls)
//                 {
//                     var youtube = YouTube.Default; 
//                     var video = await youtube.GetVideoAsync(url);
//                     videos.Add(video);
//                 }
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"‚ùå Error retrieving playlist: {ex.Message}");
//             }

//             return videos;
//         }
//     }
// }



==== test/Lyra.Tests/DownloaderServiceTests.cs ====
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Lyra.Services;
using Xunit;
using FluentAssertions;
using Microsoft.Extensions.Logging;
using NSubstitute;

namespace Lyra.Tests
{
    public class DownloaderServiceTests : IDisposable
    {
        private readonly DownloaderService _downloader;
        private readonly string _testDownloadPath;
        private readonly ILogger<DownloaderService> _mockLogger;
        private readonly ConversionService _mockConversionService;

        public DownloaderServiceTests()
        {
            // Create a unique temp test directory
            _testDownloadPath = Path.Combine(Path.GetTempPath(), "lyra_test_downloads_" + Guid.NewGuid());
            Directory.CreateDirectory(_testDownloadPath);

            _mockLogger = Substitute.For<ILogger<DownloaderService>>();
            _mockConversionService = Substitute.For<ConversionService>();

            // Inject the logger mock
            _downloader = new DownloaderService(_mockLogger, _mockConversionService);
        }

        [Fact]
        public async Task DownloadSingleVideo_ShouldDownloadAndConvertMp3()
        {
            string videoUrl = "https://www.youtube.com/watch?v=WBqf-vSMA6k"; // Example (verify it's available)

            await _downloader.DownloadVideo(videoUrl);

            // Assert the MP3 file exists
            string expectedMp3 = Directory.GetFiles(_testDownloadPath, "*.mp3").FirstOrDefault();
            expectedMp3.Should().NotBeNull("MP3 file should be created after conversion");

            _mockLogger.Received().LogInformation(Arg.Any<string>());

            Console.WriteLine($"‚úÖ Test Passed: Downloaded {expectedMp3}");
        }

        [Fact]
        public async Task DownloadPlaylist_ShouldDownloadMultipleMp3s()
        {
            string playlistUrl = "https://www.youtube.com/playlist?list=PLquujPA7EWzOoUtojEcgQJCpTkdbVG4LV"; // Example

            await _downloader.DownloadPlaylist(playlistUrl);

            // Assert multiple MP3 files exist
            var mp3Files = Directory.GetFiles(_testDownloadPath, "*.mp3");
            mp3Files.Length.Should().BeGreaterThan(1, "A playlist should contain multiple MP3 files");

            _mockLogger.Received().LogInformation(Arg.Any<string>());

            Console.WriteLine($"‚úÖ Test Passed: Downloaded {mp3Files.Length} MP3 files from playlist");
        }

        public void Dispose()
        {
            // Cleanup test directory after tests
            if (Directory.Exists(_testDownloadPath))
            {
                Directory.Delete(_testDownloadPath, true);
            }
        }
    }
}



==== test/Lyra.Tests/GlobalUsings.cs ====
global using Xunit;


